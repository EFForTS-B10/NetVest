;=========================================================================================
;=========================================================================================
;
; ATTEMPT 2:
; Modelling Marginal Biodiversity Values
; Adapted from the invest landuse change model
; Explanation can be found here: 
; https://books.google.de/books?id=s-AVDAAAQBAJ&pg=PA234&lpg=PA234&dq=calculate+%22marginal+biodiversity+value%22&source=bl&ots=VizoibzWxq&sig=6yADRPd9HcTj4wknOP2UsUDD6N0&hl=de&sa=X&ved=0ahUKEwibv9OY2IDVAhVGvxQKHXXXD4QQ6AEIMTAC#v=onepage&q=calculate%20%22marginal%20biodiversity%20value%22&f=false
;
;=========================================================================================
;=========================================================================================

to biodiv_plants_SAR_init
  
  ; Adjust landuse values 
  ; -> This is a temporary fix -> I might think about how to change the structure of the code to work with other landuse values
  ;adjust-landuse-invest
  
  ;; Read globals:
  ;; First we have to read species probability data:
  plantdiv_read_data 
  plantdiv_calculate_weights
  
  ;; In tick 0, the sar value cannot be calculated accurately, because there are no technical inputs, etc on the plots...
   
  ;; Do first calculation for initial landscape:
  ;; Here we calculate the actual MBV values
  ;plantdiv_calculate_sar
  ;; Set sar_t0
  ;set sar_t0 sar_t
  ;; Calculate ratio:
  ;set sar_ratio (sar_t / sar_t0)
  
  ; Adjust landuse values back to abm mode:
  ;adjust-landuse-abm
  
end

to biodiv_plants_SAR_update
  
  ; Adjust landuse values 
  ; -> This is a temporary fix -> I might think about how to change the structure of the code to work with other landuse values
  adjust-landuse-invest
  
  ;; Calculate sar value of landscape:
  plantdiv_calculate_sar
  
  ;; If this is the first time sar is calculated, store it a s t0:
  if (sar_t0 = 0) [set sar_t0 sar_t]
  
  ;; Calculate ratio:
  set sar_ratio (sar_t / sar_t0)
  
  ; Adjust landuse values back to abm mode:
  adjust-landuse-abm
  
end

to adjust-landuse-invest
    
  ;; TEMPORARY ADJUSTMENT:
  ;; The functions use while loops to loop trough landuses
  ;; Forest must have landuse 4
  ask patches 
  [
    if (p_landuse = -100) [set p_landuse 4]
    if (p_landuse = 1) [set p_landuse 2]
    if (p_landuse = 0) [set p_landuse 1]
    if (p_road = 1 and p_landuse = 4) [set p_landuse 0]
  ]
end

to adjust-landuse-abm
      
  ;; TEMPORARY ADJUSTMENT:
  ;; The functions use while loops to loop trough landuses
  ;; Forest must have landuse 4
  ask patches
  [
    if (p_landuse = 0) [set p_landuse -100]
    if (p_landuse = 4) [set p_landuse -100]
    if (p_landuse = 1) [set p_landuse 0]
    if (p_landuse = 2) [set p_landuse 1]
  ]
end


;*************************************************************
; Read plant probability data:
;*************************************************************
to plantdiv_read_data 

print "Read plant data..."

  ;; Reset global prob list:
  set plantdiv_all_probs []
  
  ;;; Read file:
  let filename "input/plants/species_probs.csv"
  file-open filename
  
  ;;SKip header:
  repeat 6 [let drop file-read]
  
  while [not file-at-end?]
  [
    ;;Read species and store them in lists
    let rownr file-read
    let species file-read
    let fo_prob file-read
    let jr_prob file-read
    let op_prob file-read
    let rm_prob file-read
    let group file-read
  
    ;; Create temporary list:  ["p_landuse 0 prob" "p_landuse 1 prob" "..." "p_landuse 4 prob" "species" "species-group (general/corespecies)"]
    ;; other= 0, op=1, rm=2, jr=3, fo=4
    let species_probs (list fo_prob op_prob rm_prob jr_prob fo_prob species) 
  
    set plantdiv_all_probs lput species_probs plantdiv_all_probs
  ]
  
  file-close

end

;*************************************************************
; Define weights for plants
;*************************************************************
to plantdiv_calculate_weights
  
  ;; SImple assumption - we give high weight to all species, which are forest only:
  let nr-of-species length plantdiv_all_probs
  let ws_default 1 ;(1 / nr-of-species)
  let ws_bonus 10
  set ws_list []
  
  ;; Count species with forest only:
  foreach plantdiv_all_probs
  [ ? ->
    
    let ws_temp ws_default
    
    ;; Check if forest only species:
    if ((item 4 ? > 0) and (sum (sublist ? 1 4) = 0))
    [
      set ws_temp ws_default * ws_bonus
    ]
  
    set ws_list lput ws_temp ws_list
  ]
  
end


;*************************************************************
; Calculate the SAR value of each species
;*************************************************************
to plantdiv_calculate_sar
  
  ;print "Calculate SAR values..."
  
  ;; Globals:
  ;; ws_list -> weights, used for calculating Hxst
  ;; plantdiv_all_probs --> probabilities to find species in a certain landuse
  
  ;; I need:
  ;; Axjt -> Area (A) of landuse (j) over all cells (x) at time (t)
  ;; Hxst -> Suitability (H) of cell (x) for species (s) at time (t) -- binary (1/0)
  ;; Csjt -> Habitat quality score (C) of landuse (j) for species (s) at time (t)
  ;; Ax  -> Area(A) over all cells (x)
  ;; Qx  -> Quality
  ;; gammast  -> coefficient from SAR curve: 198.0820521
  ;; zst  -> coefficient from SAR curve: 0.5677054
  
  
  ;; Pre-calculate Axj values: 
  let Axj_list crt-Axj-list       ;; List of matrices: List elements = landuses (j); Matrix cells = patches (x)  
  ;; Pre-calculate Hxs values:
  let Hxs_list crt-Hxs-list Axj_list   ;; List of matrics: List elements = species (s); Matrix cells = patches (x)
  ;; Pre-calculate Csj values:
  let Csj_list plantdiv_all_probs    ;; List of lists: Outer list elements = species (s); Inner list elements = landuse (j)
  ;; Pre-calculate Qx matrix:
  let Qx crt-Qx-matrix
  ;; Pre-calculate Ax:
  let Ax count patches
  ;; z coefficient of power function:
  let zst 0.5677054
  ;; gamma coefficient of power function:
  let gammast 198.0820521
  
  ;print Qx
  
  ;; Loop over all species (s)
  set sar []
  let s 0
  while [s < length plantdiv_all_probs]
  [
    ;; Extract Hxs matrix for current species (s)
    let Hxs item s Hxs_list
    
    ;; Prepare variable to collect matrix product sum:
    let AxjHxsCsj matrix:make-constant world-width world-height 0
    
    ;; Loop over all landuses (j)
    let j 0
    while [j <= 4]
    [
      ;; Select Axj matrix for landuse j:
      let Axj item j Axj_list
      ;; Select Csj vecotr (probs) for current species (s) and landuse (j)
      let Csj item j item s Csj_list
      ;; Calculate the matrix product:
      let AxjHxsCsj_temp (matrix:times (matrix:times-element-wise Axj Hxs) Csj)    
      ;; Save the resulting matrix by adding it up:
      set AxjHxsCsj matrix:plus AxjHxsCsj AxjHxsCsj_temp
      ;; Increase loop iterator
      set j (j + 1)
    ] ; end of landuse loop (j)
    
    ;; Multiply with quality:
    let AxjHxsCsjQx_sum_j (matrix:times-element-wise AxjHxsCsj Qx)
    ;; Calculate the sum over all cells:
    let AxjHxsCsjQx_sum_xj sum map [ij -> sum ij] matrix:to-row-list AxjHxsCsjQx_sum_j

 ;   print AxjHxsCsj_sum_xj
    
    ;; Caluclate AxHxs:
    let AxHxs (matrix:times Ax Hxs)
    let AxHxs_sum_x sum map [ij -> sum ij] matrix:to-row-list AxHxs
    
    ;; QUICKFIX TO PREVENT DIVISION ZERO:
    set AxHxs_sum_x (AxHxs_sum_x + 0.000001)  
    let AxHxs_sum_x_power_z (AxHxs_sum_x ^ zst)
    
    ;; Add power function coefficient:
    let AxjHxsCsjQx_sum_xj_power_z (AxjHxsCsjQx_sum_xj ^ zst)
    
    ;; Calculate sar value for species (s)
    let sar_st (gammast * (AxjHxsCsjQx_sum_xj_power_z / AxHxs_sum_x_power_z))
    
  ;  print sar_st
    
    ;; Store result in global list:
    set sar lput sar_st sar
    
    ;print (word "sar_st: " sar_st)
    
    ;; Increase loop iterator
    set s (s + 1)
  ] ; end of species loop (s)
  
  ;; Calculate weighted sar
  let sar_ws (map * ws_list sar)
  
  ;; Calculate sum:
  set sar_t sum sar_ws
  
end


;*************************************************************
; Helper function that creates a potential distribution matrix of a species (suitable habitat)
;*************************************************************

to-report crt-Hxs-list [Axj-list]
  
  let Hxs_list []
  
  foreach plantdiv_all_probs
  [ s ->
    
    let Hxs_temp matrix:make-constant world-width world-height 0
 
    ;; Check first item of axk list and first prob of sp-prob
    let i 0
    foreach Axj-list
    [ Axj_i ->
      if (item i s > 0)
      [
        set Hxs_temp matrix:plus Hxs_temp Axj_i
      ]
      set i (i + 1)
    ]
  
    ;; Now each cell which is > 0 is potential habitat:
    set Hxs_temp matrix:map [? -> ifelse-value (? > 0)[1][0]] Hxs_temp
    set Hxs_list lput Hxs_temp Hxs_list
  ]
  
  report Hxs_list
  
end

;*************************************************************
; Helper function that creates a matrix of moving window land use fractions of each cell
;*************************************************************
to-report crt-Axj-list

  let Axj_list []
  let j 0
  let cell-weight 0.6
  
  while [j <= 4]
  [
    let Axj_temp matrix:make-constant world-width world-height 0
   
    ask patches
    [ 
      let nbr-weight ((1 - cell-weight) / count neighbors)
      ;; Calculate the fraction of the current landuse in this cell
      let p_landuse_frac ((nbr-weight * count neighbors with [p_landuse = j]) + (cell-weight * ifelse-value (p_landuse = j)[1][0]))
      ;; Store the result in the matrix
      matrix:set Axj_temp pxcor pycor p_landuse_frac
    ]
    
    set Axj_list lput Axj_temp Axj_list
    set j (j + 1)
  ]
  report Axj_list
  
end

;*************************************************************
; Helper function that creates a habitat quality matrix for each landuse in each cell
;*************************************************************

to-report crt-Qx-matrix
  
    
  let Qx_temp matrix:make-constant world-width world-height 0
 
  ask patches
  [
    let q_x ifelse-value (p_landuse = 4) [calculate-patch-quality-forest][calculate-patch-quality-agri]
    matrix:set Qx_temp pxcor pycor q_x
  ]
  
  report Qx_temp
end

;to-report calculate-patch-quality
;  
;  ; we set all forest cells to 1
;  ; we set all agriculture cells to 0.5
;  ; we give an edge bonus to all cells that have an edge to forest
;  ; finally, for all agricultural cells we reduce the quality depending on age with age 0 = min quality
;  
;  let q-forest-const 1
;  let q-agri-max 0.5
;  let q-edge-bonus 0.1
;  let q-agri-min 0.1
;  let q-p_age-best 15
;  let q-p_age-step (q-agri-max / q-p_age-best)
;  
;  let q_x 0
;  
;  ;; Forest:
;  ifelse (p_landuse = 4)
;  [
;    set q_x q-forest-const
;  ]
;  [ ;; Agriculture:
;    set q_x q-agri-max   ;ifelse-value (any? neighbors with [p_landuse = 4]) [q-agri-max][q-agri-max - q-noedge-malus]
;    
;    ;; Scale to p_age:
;    if (p_age < q-p_age-best)
;    [
;      let age-diff q-p_age-best - p_age
;      set q_x q_x - (age-diff * q-p_age-step)
;    ]
;    
;    ;; Edge bonus:
;    if (any? neighbors with [p_landuse = 4]) [set q_x q_x + q-edge-bonus]
;    
;  ]
;  
;  report q_x
;    
;end

to-report calculate-patch-quality-forest  ; patch function
  
  let hq_forest 1
  report hq_forest

end

to-report calculate-patch-quality-agri  ; patch function
  
  ;; Patch quality is a function of patch_age, amount of forest edges and technical inputs:
  ;; High plantation age is better than very young age
  ;; More forest edges are better
  ;; Low technical inputs are better
  
  ;; We may use a regression model to model this relationship, butfor now we just use simple assumptions:
  
  ;; Scale tinput to 0..1
  ;; NewValue = (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
  let tinput_min 0
  let tinput_max 185
  let tinput_scaled (((p_tinput - tinput_min) * (1 - 0)) / (tinput_max - tinput_min)) + 0
  set tinput_scaled (1 - tinput_scaled)  ;; reverse (high tinput = low quality)
    
  ;; Scale edge cells to 0..1
  let edge_min 0
  let edge_max 8
  let p_edge count neighbors with [p_landuse = 4]
  let edge_scaled (((p_edge - edge_min) * (1 - 0)) / (edge_max - edge_min)) + 0
  
  ;; Scale plantation age to 0..1
  let age_min 0
  let age_max 50
  let age_scaled (((p_age - age_min) * (1 - 0)) / (age_max - age_min)) + 0
  
  ;; Calculate weighted mean score:
  let w_tinput 0.4
  let w_age 0.4
  let w_edge 0.2
  
  let hq_weighted (((tinput_scaled * w_tinput) + (edge_scaled * w_edge) + (age_scaled * w_age)) / (w_tinput + w_age + w_edge))
  ;print hq_weighted
  report hq_weighted
  
end


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;
;; The outcommented part below contains functions to calculate the SAR based biodiversity values for each cell instead of a landscape-scale index
;;
;;
;;=========================================================================================
;;=========================================================================================
;;
;; ATTEMPT 1:
;; Modelling Marginal Biodiversity Values
;; Adapted from the invest landuse change model
;; Explanation can be found here: 
;; https://books.google.de/books?id=s-AVDAAAQBAJ&pg=PA234&lpg=PA234&dq=calculate+%22marginal+biodiversity+value%22&source=bl&ots=VizoibzWxq&sig=6yADRPd9HcTj4wknOP2UsUDD6N0&hl=de&sa=X&ved=0ahUKEwibv9OY2IDVAhVGvxQKHXXXD4QQ6AEIMTAC#v=onepage&q=calculate%20%22marginal%20biodiversity%20value%22&f=false
;;
;;=========================================================================================
;;=========================================================================================
;
;to init_invest_plantdiv
;  
;  ; Adjust landuse values 
;  ; -> This is a temporary fix -> I might think about how to change the structure of the code to work with other landuse values
;  adjust-landuse-invest
;  
;  ;; Read globals:
;  ;; First we have to read species probability data:
;  plantdiv_read_data 
;  ;; Then we define weights to the species
;  plantdiv_calculate_weights
;  
;  ;; Do first calculation for initial landscape:
;  ;; Here we calculate the actual MBV values
;  plantdiv_calculate_mbv
;  
;  ;; Paint mbv as scale color
;  ;plantdiv_paint_mbv
;  
;  ;; Store the base-landscape mbv value:
;  ask patches[set p_MBVx p_MBV set p_RMBV []]
;  
;  ; Adjust landuse values back to abm mode:
;  adjust-landuse-abm
;  
;end
;
;to update_invest-Plantdiv
;  
;  ; Adjust landuse values 
;  ; -> This is a temporary fix -> I might think about how to change the structure of the code to work with other landuse values
;  adjust-landuse-invest
;  
;  ;; Do first calculation for initial landscape:
;  ;; Here we calculate the actual MBV values
;  plantdiv_calculate_mbv
;  
;  ;; Paint mbv as scale color
;  ;plantdiv_paint_mbv
;  
;  ask patches[set p_RMBV lput (p_MBV / p_MBVx) p_RMBV]
;  
;  plot_invest_plantdiv
;  
;  ; Adjust landuse values back to abm mode:
;  adjust-landuse-abm
;  
;end
;
;to adjust-landuse-invest
;    
;  ;; TEMPORARY ADJUSTMENT:
;  ;; The functions use while loops to loop trough landuses
;  ;; Forest must have landuse 4
;  ask patches 
;  [
;    if (p_landuse = -100) [set p_landuse 4]
;    if (p_landuse = 1) [set p_landuse 2]
;    if (p_landuse = 0) [set p_landuse 1]
;    if (p_road = 1 and p_landuse = 4) [set p_landuse 0]
;  ]
;end
;
;to adjust-landuse-abm
;      
;  ;; TEMPORARY ADJUSTMENT:
;  ;; The functions use while loops to loop trough landuses
;  ;; Forest must have landuse 4
;  ask patches
;  [
;    if (p_landuse = 0) [set p_landuse -100]
;    if (p_landuse = 4) [set p_landuse -100]
;    if (p_landuse = 1) [set p_landuse 0]
;    if (p_landuse = 2) [set p_landuse 1]
;  ]
;end
;
;
;;*************************************************************
;; Read plant probability data:
;;*************************************************************
;to plantdiv_read_data 
;
;print "Read plant data..."
;
;  ;; Reset global prob list:
;  set plantdiv_all_probs []
;  
;  ;;; Read file:
;  let filename "input/plants/species_probs.csv"
;  file-open filename
;  
;  ;;SKip header:
;  repeat 6 [let drop file-read]
;  
;  while [not file-at-end?]
;  [
;    ;;Read species and store them in lists
;    let rownr file-read
;    let species file-read
;    let fo_prob file-read
;    let jr_prob file-read
;    let op_prob file-read
;    let rm_prob file-read
;    let group file-read
;  
;    ;; Create temporary list:  ["p_landuse 0 prob" "p_landuse 1 prob" "..." "p_landuse 4 prob" "species" "species-group (general/corespecies)"]
;    ;; other= 0, op=1, rm=2, jr=3, fo=4
;    let species_probs (list fo_prob op_prob rm_prob jr_prob fo_prob species) 
;  
;    set plantdiv_all_probs lput species_probs plantdiv_all_probs
;  ]
;  
;  file-close
;
;end
;
;;*************************************************************
;; Define weights for plants
;;*************************************************************
;to plantdiv_calculate_weights
;  
;  ;; SImple assumption - we give high weight to all species, which are forest only:
;  let nr-of-species length plantdiv_all_probs
;  let ws_default (1 / nr-of-species)
;  let ws_bonus 1.5
;  set ws_list []
;  
;  ;; Count species with forest only:
;  foreach plantdiv_all_probs
;  [ ? ->
;    
;    let ws_temp ws_default
;    
;    ;; Check if forest only species:
;    if ((item 4 ? > 0) and (sum (sublist ? 1 4) = 0))
;    [
;      set ws_temp ws_default * ws_bonus
;    ]
;  
;    set ws_list lput ws_temp ws_list
;  ]
;  
;end
;
;
;
;;*************************************************************
;; Calculate the MBV value of each cell
;;*************************************************************
;to plantdiv_calculate_mbv
;  
;  print "Calculate CAH matrix..."
;  
;  let Axk_list crt-Axk-list
;  let HxsWs_list []
;  
;  ;; Prepare empty list for CsjD results (one CsjD value for each landuse)
;  let CsjD_all []
;  let s 0
;  foreach plantdiv_all_probs
;  [ probs ->
;     ;; Create a potential range matrix for this species:
;    let Hxs crt-Hxs probs Axk_list
;    let ws item s ws_list
;    set HxsWs_list lput (matrix:times Hxs ws) HxsWs_list
;    let CsjD_list []
;    
;    let j 0
;    while [j <= 4]
;    [ 
;      
;     
;      ;; Select the current main landuse probability for this species:
;      let Csj item j probs
;      let CsAkHs 0
;      
;      ;; Loop trough other landuses:
;      let k 0
;      while [k <= 4]
;      [
;        ;;Select the current Axk from the Axk list 
;        let Axk item k Axk_list
;        ;; Select the prorbability for this landuse from the species list
;        let Csk item k probs
;        
;        ;; Calculate the matrix product:
;        let CskAxkHxs (matrix:times-scalar (matrix:times-element-wise Axk Hxs) Csk)
;        
;        ;; Sum up over all cells x:
;        set CsAkHs (CsAkHs + (sum (map [? -> sum ?] matrix:to-row-list CskAxkHxs)))
;        ;print CsAkHs
;        set k (k + 1)
;      ];;end of while k
;      
;      let CsjD_temp ifelse-value(CsAkHs != 0) [(Csj / CsAkHs)][0]
;      
;      set CsjD_list lput CsjD_temp CsjD_list 
;      
;      set j (j + 1)
;      
;    ] ;;end of while j
;    
;    set CsjD_all lput CsjD_list CsjD_all
;    set s (s + 1)
;  ]     
;   
;   print "Now distributing MBV values to patches..." 
;  ;; Distribute to patches
;   let MBVx matrix:make-constant world-width world-height 0
;   set s 0
;   
;   foreach plantdiv_all_probs
;   [
;     let AxjCsjd matrix:make-constant world-width world-height 0
;     let j 0
;     
;     while [j <= 4]
;     [
;       ;; Select the current Axk from the Axklist:
;       let Axj item j Axk_list
;       let CsjD (item j (item s CsjD_all))
;       
;       set AxjCsjd (matrix:plus AxjCsjd (matrix:times Axj CsjD))
;       
;       set j (j + 1)
;     ]
;     
;    let HxsWs item s HxsWs_list
;    
;    let MBVx_temp (matrix:times-element-wise HxsWs AxjCsjD)
;    
;    set MBVx (matrix:plus MBVx MBVx_temp)
;     
;    set s (s + 1)
;   ]
;  
;   ask patches
;   [
;     set p_mbv matrix:get MBVx pxcor pycor
;    ;print p_mbv
;   ]
;       
;       
;
;  
;end
;
;;*************************************************************
;; Helper function that creates a potential distribution matrix of a species
;;*************************************************************
;
;to-report crt-Hxs [sp-prob-list Axk-list]
;  
;  let Hxs_temp matrix:make-constant world-width world-height 0
; 
;  ;; Check first item of axk list and first prob of sp-prob
;  let i 0
;  foreach Axk-list
;  [ axk_j ->
;    if (item i sp-prob-list > 0)
;    [
;      set Hxs_temp matrix:plus Hxs_temp axk_j
;    ]
;    
;    set i (i + 1)
;  ]
;  
;  ;print (word "Hxs_temp before map: " Hxs_temp)
;  
;  ;; Now each cell which is > 0 is potential habitat:
;  set Hxs_temp matrix:map [? -> ifelse-value (? > 0)[1][0]] Hxs_temp
;  ;print (word "Hxs_temp after map: " Hxs_temp)
;  report Hxs_temp
;  
;end
;
;;*************************************************************
;; Helper function that creates a matrix of moving window land use fractions of each cell
;;*************************************************************
;to-report crt-Axk-list
;
;  let Axk_list []
;  let k 0
;  let cell-weight 0.6
;  
;  while [k <= 4]
;  [
;    let Axk_temp matrix:make-constant world-width world-height 0
;   
;    ask patches
;    [ 
;      let nbr-weight ((1 - cell-weight) / count neighbors)
;      ;; Calculate the fraction of the current landuse in this cell
;      let p_landuse_frac ((nbr-weight * count neighbors with [p_landuse = k]) + (cell-weight * ifelse-value (p_landuse = k)[1][0]))
;      ;; Store the result in the matrix
;      matrix:set Axk_temp pxcor pycor p_landuse_frac
;    ]
;    
;    set Axk_list lput Axk_temp Axk_list
;    set k (k + 1)
;  ]
;  report Axk_list
;  
;end
;
;
;
;;*************************************************************
;; Paint mbv values of cells as scale color
;;*************************************************************  
;to plantdiv_paint_mbv
;  
;  let min_p_mbv min [p_mbv] of patches
;  let max_p_mbv max [p_mbv] of patches
;  
;  ask patches
;  [
;    set pcolor scale-color green p_mbv min_p_mbv max_p_mbv 
;  ]
;end
;
;
;
;to invest_plantdiv_paint_rmbv
;  
;  let time invest_plantdiv_paint_t   
;  let min_rmbv 0.5 ;min map [? -> item time ?] [p_RMBV] of patches
;  let max_rmbv 1.5 ;max map [? -> item time ?] [p_RMBV] of patches
;
;  ask patches
;  [
;    set pcolor ifelse-value (item time p_rmbv >= 1)
;    [
;      scale-color green item time p_RMBV max_rmbv 1
;    ]
;    [
;      scale-color red item time p_RMBV min_rmbv 1
;    ]
;    
;  ]
;  
;  display
;    
;end
;
;to plot_invest_plantdiv
;  
;  set-current-plot "invest_plantdiv"
;  set-current-plot-pen "op"
;  plot mean [(p_MBV / p_MBVx)] of patches with [p_landuse = 1]
;    
;  set-current-plot-pen "rm"
;  plot mean [(p_MBV / p_MBVx)] of patches with [p_landuse = 2]
;  
;  set-current-plot-pen "fo"
;  plot mean [(p_MBV / p_MBVx)] of patches with [p_landuse = 4]
;  
;  set-current-plot-pen "total"
;  plot mean [(p_MBV / p_MBVx)] of patches
;  
;  set-current-plot "invest_plantdiv_hist"
;  set-current-plot-pen "op"
;  histogram [(p_MBV / p_MBVx)] of patches with [p_landuse = 1]
;  set-current-plot-pen "rm"
;  histogram [(p_MBV / p_MBVx)] of patches with [p_landuse = 2]
;  
;  
;  
;end
