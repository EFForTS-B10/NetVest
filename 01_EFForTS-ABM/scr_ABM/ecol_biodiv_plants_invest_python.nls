;; First define on which machine (local-windows, local-linux or server) we want to run the model
to biodiv_plants_invest_python_init
 (ifelse which-machine? = "server" [set-up-invest get-sys-info write-tables]  ;; If simulation runs on the server than via docker-container
  which-machine? = "local-windows" [write-tables]                             ;; If Simulation runs on your local Windowsmachine, we connect to a netlogo nls-file for testing which returns artificial values (as python version on windows does not work)
  which-machine? = "local-linux"   [set-up-invest get-sys-info write-tables]) ;; If simulation runs on you local Linux-machine, we connect to python executable and load environment
end

;; Setup the connection to python and import a few libraries
to set-up-invest
  print["setting up invest"]
  (ifelse which-machine? = "local-linux"
      ;[py:setup py:python3]
    ;[py:setup "/home/cloud/anaconda3/envs/forge/bin/python"]
    [py:setup "/home/ecomod/anaconda3/envs/forge/bin/python"]
     ;[py:setup "C:/Users/JuliaHenzler/AppData/Local/Programs/Python/Python39/python"]        ;pip environment: enter path to your python executable
                                 ;anaconda environment: alternative to pip environment
    which-machine? = "server"
     [py:setup py:python3])
  py:run "import sys"
  py:run "import os"
  py:run "import natcap.invest"
  py:run "from natcap.invest import habitat_quality"
  py:run "from osgeo import gdal, osr"
end

;; Usage of the `sys` package in python to output some system info
to get-sys-info
  output-print (word "Python directory: " (py:runresult "sys.prefix"))
  output-print (word "Platform: " (py:runresult "sys.platform"))
  (py:run
    "print(os.getcwd())"
  )

  let home-dir py:runresult "os.environ['HOME']"
  output-print (word "Current home directory is: " home-dir)

  output-print ""
end

;; Generation of csv-tables
to write-tables
  write-sensitivity
  write-impact
end

;; Read in sensitivity-table (depending on research objective) from input-folder and generate sensitivity-table
to write-sensitivity
  print ["read in and write sensitivity-table"]
  ;; Reset global sensitivity-list
  let sensitivity_all []
  let filename  0
  ;; Read file depending on research objective
  (ifelse biodiv_invest_objective = "general"          [set filename "input/habitatquality/sensitivitytable_genbiodiv_binary_spatial.txt"]
          biodiv_invest_objective = "modelorg_plants"  [print "Warning: Biodiversity of modelorganism not yet implemented"]
          biodiv_invest_objective = "all_plants"       [print "Warning: Biodiversity of all plants not yet implemented"])
  ifelse filename = 0 [stop]
  [
  file-open filename

  while [not file-at-end?]
  [
    ;;Read data for previous defined research objective and correlated habitat-suitability
    let LULC file-read
    let NAME file-read
    let HABITAT file-read
    let L_village file-read
    let L_lc_r file-read
    let L_lc_o file-read
    let L_tinput_r file-read
    let L_tinput_o file-read
    let L_labor_r file-read
    let L_labor_o file-read

    ;; Generate temporary sensitivity-list
    let sensitivity (list LULC NAME HABITAT L_village L_lc_r L_lc_o L_tinput_r L_tinput_o L_labor_r L_labor_o)
    ;print sensitivity

    set sensitivity_all lput sensitivity sensitivity_all
  ]
    ;; Store sensitivity_table.csv to output folder
    csv:to-file "output/sensitivity_table.csv" sensitivity_all

  file-close
  ]

;; Pyhthon-version of csv-writing
;  (py:run
;    "csv_path = 'output/sensitivity_table.csv'"
;    "with open(csv_path, 'w') as open_table:"
;    "  open_table.write('LULC,NAME,HABITAT,L_village,L_lc_r,L_lc_o,L_tinput_r,L_tinput_o,L_labor_r,L_labor_o\\n')"
;    "  open_table.write('1,village,0,0,0\\n')"
;    "  open_table.write('2,oil_palm,0,0,0\\n')"
;    "  open_table.write('3,rubber,0,0,0\\n')"
;    "  open_table.write('4,forest,1,0.5,0.5\\n')"
;  )
end


;; Read in impact-table from input-folder and generate impact-table
to write-impact
  print ["read in and write impact-table"]
  set impact_all []
  set impact_max 0
  let filename "input/habitatquality/impacttable_equalweight_spatial.txt"
  ifelse filename = 0 [stop]
  [
  file-open filename

  while [not file-at-end?]
  [
    ;;Read data for impact-table
    let THREAT file-read
    let MAX_DIST file-read
    let WEIGHT file-read
    let DECAY file-read

    ;; Generate temporary impact-list
    let impact (list THREAT MAX_DIST WEIGHT DECAY)
    ;print impact

    set impact_all lput impact impact_all
       
    ;set impact_max impact_max + max [MAX_DIST] of impact
    ;show impact_max  
  ]
    ;; Store impact_table.csv to output folder
    csv:to-file "output/impact_table.csv" impact_all

  file-close
  ]
<<<<<<< HEAD
  
  foreach impact_all
    if item 1 > impact_max
      [set impact_max item 2]
    show impact_max
  
;; Python-Version of writing impact-table  
=======

;; Python-Version of writing impact-table
>>>>>>> fd3c4881b6a1dbc41c4a4c70786da876bb1336ca
;  (py:run
;    "csv_path = 'output/threats_samp.csv'"
;    "with open(csv_path, 'w') as open_table:"
;    "  open_table.write("
;    " 'THREAT,MAX_DIST,WEIGHT,DECAY\\n'"
;  ")"
;    "  open_table.write('oil_palm,1.0,0.5,exponential\\n')"
;    "  open_table.write('rubber,1.0,1.0,exponential\\n')"
;  )
end


to biodiv_plants_invest_python_update
  ifelse which-machine? = "server" and which-machine? = "local-linux"
  [translate-to-lulc-invest
   write-maps
   convert-maps
   run-invest
   convert-habitat-quality-to-asc
   save-habitat-quality-to-patch
   aggregate-habitat-quality]

  [translate-to-lulc-invest
   write-maps
   run-dummy-invest
   save-habitat-quality-to-patch
   aggregate-habitat-quality]
end


;; Create new variable for lulc-classification as p_landuse is still used
to translate-to-lulc-invest
  print["translating map"]
  ask patches
  [
    if (p_landuse = -100 and p_homebase = -1) [set p_landuse_invest 4] ;forest
    if (p_landuse = 1) [set p_landuse_invest 3] ;rubber
    if (p_landuse = 0) [set p_landuse_invest 2] ;oilplam
    if (p_landuse = -100 and p_homebase >= 0) [set p_landuse_invest 1] ;village
  ]
end

;; create new patch-variable for threat-location on the map
;to p_impact-values
;  print ["generating p_impact-values"]
;  ;let p_impact-value 0
;  ask patches
;  [
;    if (p_landuse_invest = 1) [set p_impact-value 1] ; village
;    if (p_landuse_invest = 3 and p_age = 0 and p_invest > 0 ) [set p_impact-value 2] ; lc_r: land clearing rubber: investment costs occur only during immature phase. How extracting first year of investmentcost as this is the year after land clearing?
;    if (p_landuse_invest = 2 and p_age = 0 and p_invest > 0) [set p_impact-value 3] ; lc_o: land clearing oilpalmt
;    if (p_landuse_invest = 3 and p_tinput > 0) [set p_impact-value 4] ; tinput_r: technical input rubber
;    if (p_landuse_invest = 2 and p_tinput > 0) [set p_impact-value 5] ; tinput_o: technical input oilpalm
;    if (p_landuse_invest = 3 and p_labor > 0) [set p_impact-value 6] ; labor_r: labor input rubber
;    if (p_landuse_invest = 2 and p_labor > 0) [set p_impact-value 7] ; labor_o: labor input oilpalm
;  ]
;end


;; Generation of LULC-raster-map and impact-maps (as much as impacts we have)
to write-maps
  print["writing maps to disk"]
  write-lulc-map
  write-impact-map "village"
  write-impact-map "lc_o"
  write-impact-map "lc_r"
  write-impact-map "tinput_r"
  write-impact-map "tinput_o"
  write-impact-map "labor_r"
  write-impact-map "labor_o"
end


;; Generation of LULC-map
to write-lulc-map
  let new-raster gis:patch-dataset p_landuse_invest
  let filename (word "output/lulc.asc")
  if (file-exists? filename) [file-delete filename]
  gis:store-dataset new-raster filename
end

; generation of LULC-map: complicated way
;to write-lulc-map-complicated
;  ; Write landuse map
;  let new-raster gis:create-raster (max-pxcor + 1) (max-pycor + 1) gis:world-envelope
;  let xcount 0
;  let ycount max-pycor
;  let ycount-raster 0
;  while [ycount >= 0]
;  [
;    while[xcount <= max-pxcor]
;    [
;      gis:set-raster-value new-raster xcount ycount-raster [p_landuse_invest] of patch xcount ycount
;      set xcount xcount + 1
;    ]
;    set xcount 0
;    set ycount ycount - 1
;    set ycount-raster ycount-raster + 1
;  ]
;
;  let filename (word "output/lulc.asc")
;  if (file-exists? filename) [file-delete filename]
;  gis:store-dataset new-raster filename
;end

;; Generation of impact-maps
to write-impact-map [impact-name]
  ask patches
  [set p_impact-location FALSE]
  print["writing impact map"]
  ;; iterate throug all possible impacts
  show impact-name
  (ifelse
    impact-name = "village"
    [ask patches with [p_landuse_invest = 1] [set p_impact-location TRUE]
    ;[if ([p_impact-value] of patches = 1) [set [p_impact] of patches = TRUE]
     print ["creating village impact map"]]
    impact-name = "lc_r"
      [ask patches with [p_landuse_invest = 3 and p_age = 0 and p_invest > 0] [set p_impact-location TRUE]
       print ["creating land clearing rubber impact map"]]
    impact-name = "lc_o"
      [ask patches with [p_landuse_invest = 2 and p_age = 0 and p_invest > 0] [set p_impact-location TRUE]
       print ["creating land clearing oilpalm impact map"]]
    impact-name = "tinput_r"
      [ask patches with [p_landuse_invest = 3 and p_tinput > 0] [set p_impact-location TRUE]
       print ["creating technical input rubber impact map"]]
    impact-name = "tinput_o"
      [ask patches with [p_landuse_invest = 2 and p_tinput > 0] [set p_impact-location TRUE]
       print ["creating technical input oilpalm impact map"]]
    impact-name = "labor_r"
      [ask patches with [p_landuse_invest = 3 and p_labor > 0] [set p_impact-location TRUE]
       print ["creating labor input rubber impact map"]]
    impact-name = "labor_o"
      [ask patches with [p_landuse_invest = 2 and p_labor > 0] [set p_impact-location TRUE]
       print ["creating labor input oilpalm impact map"]]
  )
  let new-raster gis:create-raster (max-pxcor + 1) (max-pycor + 1) gis:world-envelope
  let xcount 0
  let ycount max-pycor
  let ycount-raster 0
  while [ycount >= 0]
  [
    while[xcount <= max-pxcor]
    [
      ;show [p_landuse] of patch xcount ycount = threat-value
      ;if ([p_landuse_invest] of patch xcount ycount = threat-value) [print threat-name]
      ifelse ([p_impact-location] of patch xcount ycount = TRUE)
          [gis:set-raster-value new-raster xcount ycount-raster 1]
          [gis:set-raster-value new-raster xcount ycount-raster 0]
      set xcount xcount + 1
    ]
    set xcount 0
    set ycount ycount - 1
    set ycount-raster ycount-raster + 1
  ]

  ;; store impact-map
  let filename (word "output/" (word (impact-name)) "_c.asc")
  if (file-exists? filename) [file-delete filename]
  gis:store-dataset new-raster filename

  ask patches [set p_impact-location FALSE]
end


;; Conversion of asc-maps to tif-maps for transferation to InVEST
to convert-maps
  foreach ["lulc" "village_c" "lc_r_c" "lc_o_c" "tinput_r_c" "tinput_o_c" "labor_r_c" "labor_o_c"]
  [
    [x] ->
    convert_to_tif x
  ]
end


to convert_to_tif [filename]
  py:set "filename" filename
  (py:run
    "drv = gdal.GetDriverByName('GTiff')"
    "ds_in = gdal.Open(f'output/{filename}.asc')"
    "ds_out = drv.CreateCopy(f'output/{filename}.tif', ds_in)"
    "srs = osr.SpatialReference()"
    "srs.ImportFromEPSG(32748)"
    "ds_out.SetProjection(srs.ExportToWkt())"
    "ds_out.GetRasterBand(1).SetNoDataValue(-9999)"
    "ds_in = None"
    "ds_out = None"
  )
end


;; Invoke model InVEST and transfer output
to run-invest
  (py:run
    "print('setting up parameters')"
    "working_directory = 'output'"
    "args = {"
    "'half_saturation_constant': '0.05',"
    "'results_suffix': 'spatial',"
    "'workspace_dir': working_directory,"
    "'lulc_cur_path': os.path.join(working_directory, 'lulc.tif'),"
    "'sensitivity_table_path': os.path.join(working_directory, 'sensitivity_table.csv'),"
    "'threat_raster_folder': working_directory,"
    "'threats_table_path': os.path.join(working_directory, 'impact_table.csv'),"
    "}"
    "habitat_quality.execute(args)"
  )
end


;; Convertion of tif-file from InVEST to asc-file for netlogo
to convert-habitat-quality-to-asc
  print["converting invest results to asc"]
  (py:run
    "filename = 'output/output/quality_c_test'"
    "in_name = f'{filename}.tif'"
    "out_name = f'{filename}.asc'"
    "gdal.Translate(out_name, in_name,format='AAIGrid')"
  )
end



;; save habitat quality of every parcel as patch-variable
to save-habitat-quality-to-patch
  print["saving habitat quality patch variable"]
  let quality-outputfile-name ""
    ifelse which-machine? = "local-windows"
    [
      set quality-outputfile-name "output/output/quality_c_dummy.asc"
    ]
    [
      set quality-outputfile-name "output/output/quality_c_test.asc"
    ]

  let qualitydata gis:load-dataset quality-outputfile-name ; adjust filename depending on outputfile from invest or dummy-invest
  gis:apply-raster qualitydata p_habitat_quality
end

to aggregate-habitat-quality
  print ["aggregating habitat quality scores"]
  set landscape-hq 0
  set landscape-hq mean [p_habitat_quality] of patches
end
