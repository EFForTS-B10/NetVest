####
# R script for creating GBM paths of correlated daily asset prices. In this 
# example, we do this for Nordstrom, Microsoft and Starbucks. 
#
# November 24, 2014
####

GBM <- function(N, sigma, mu, S0, Wt = NULL) {
  # Creates a single asset path of daily prices using Geometric Brownian Motion. 
  # One year is 252 days since that is about how many trading days are in any
  # given year.
  #
  # Args:
  #   N: Number of days in the path.
  #   sigma: Volatility or standard deviation of daily continuously compounded 
  #          returns.
  #   mu: Drift or average daily continuously compounded returns. 
  #   S0: The initial price of the asset. 
  #   Wt: The cumulative Brownian motion of the model. This can be supplied or 
  #       left as NULL. In the case that it is NULL, a vector will be provided.
  #       If you include this argument, it must be a vector of length N of the 
  #       cumulative sum of a random variable to work properly. 
  #
  # Returns:
  #   A vector of length N containing the asset prices generated by the specified
  #   GBM. 
  if (is.null(Wt)) {
    Wt <- cumsum(rnorm(N, 0, 1))
  }
  t <- (1:N)/252
  p1 <- (mu - 0.5*(sigma*sigma)) * t
  p2 <- sigma * Wt
  St = S0 * exp(p1 + p2)
  return(St)
}

CorrelatedGBM <- function(N, S0, mu, sigma, cor.mat) {
  # Creates a matrix of correlated daily price paths using Geometric 
  # Brownian Motion. 
  #
  # Args: 
  #   N: Number of days in the path.
  #   mu: Drift or average daily continuously compounded returns.  
  #   sigma: Volatility or standard deviation of daily continuously compounded 
  #          returns. 
  #   S0: The initial price of the asset. 
  #   cor.mat: The correlation matrix of the daility contiuously compounded 
  #            returns. 
  #
  # Returns:
  #   A matrix of simulated daily price paths of length N having the same number
  #   of assets as in the mu and sigma vectors. Note that mu and sigma must have
  #   the same dimensions. 
  mu <- as.matrix(mu)
  sigma <- as.matrix(sigma)
  GBMs <- matrix(nrow = N, ncol = nrow(mu))
  Wt <- matrix(rnorm(N * nrow(mu), 0, 1), ncol = nrow(mu))
  Wt <- apply(Wt, 2, cumsum)
  chol.mat <- chol(cor.mat) # upper triangular cholesky decomposition
  Wt <- Wt %*% chol.mat   # key trick for creating correlated paths
  for (i in 1:nrow(mu)) {
    GBMs[,i] <- GBM(N, sigma[i], mu[i] , S0[i], Wt[, i])
  }
  return(GBMs)
}

GetPrices <- function(crop) {
  # Gets price information from Yahoo based on ticker information and the 
  # specified start date. 
  #
  # Args:
  #   tickers: A vector of the ticker symbols to download.
  #   startDate: The beginning date. Defaults to 1/2/1992.
  #
  # Returns:
  #   A zoo object with the price information. 
  
  if (!crop %in% c("oilpalm", "rubber"))
  {
    stop("Selected crop is currently not supported!")
  }
  
  prices <- read.csv("03_Analyses/04_testing_Refforts/wb_prices.csv", sep=",", header=TRUE)
  prices$time <- seq(as.Date("1960/01/01"), by = "month", length.out = nrow(prices))
  prices.op <- prices %>% dplyr::select(time, oilpalm)
  prices.rm <- prices %>% dplyr::select(time, rubber)
  
  prices.op.zoo <- read.zoo(prices.op, format = "%Y-%m-%d")
  prices.rm.zoo <- read.zoo(prices.rm, format = "%Y-%m-%d")
  
  if(crop == "oilpalm")
  {
    prices <- prices.op.zoo
  }
  
  if(crop == "rubber")
  {
    prices <- prices.rm.zoo
  }
  
  return(prices)
}

#### generate multiple ts:
generateOneSeries <- function(years, id)
{
  N <- years * 12 # 50 years, each with 12 month
  t <- (1:N)/12 # 50 years with 12 month
  my.prices <- GetPrices()
  
  # get the cc returns and vectors of average returns and volaitiliy
  my.returns.mat <- as.matrix(na.omit(diff(log(my.prices))))
  my.mean.vec <- as.numeric(colMeans(my.returns.mat))
  my.sigma.vec <- as.numeric(sqrt(apply(my.returns.mat, 2, var)))
  my.prices.vec <- as.numeric(prices[nrow(prices)])
  my.cor.mat <-as.matrix(cor(my.returns.mat))
  
  # make correlated asset paths
  paths <- as.tibble(CorrelatedGBM(N, my.prices.vec , my.mean.vec, my.sigma.vec, my.cor.mat)) %>% 
    dplyr::mutate(time = seq(as.Date("1960/01/01"), by = "month", length.out = N)) %>% 
    dplyr::rename(oilpalm = V1, rubber = V2) %>% 
    tidyr::pivot_longer(cols=c(oilpalm, rubber)) %>% 
    dplyr::mutate(id=id)
  
  return(paths)
}

clusterSeries <- function(series, crop)
{
  
  ts <- purrr::map(unique(path.series$id), function(x) {
    series.x <- path.series %>% 
      dplyr::filter(name == crop) %>% 
      dplyr::filter(id == x)
    return(series.x$value)
  })
  
  pc <- dtwclust::tsclust(ts,
                          type = "partitional", 
                          k = 20L, 
                          distance = "dtw_basic", 
                          centroid = "pam", 
                          seed = 3247L, 
                          trace = TRUE,
                          args = tsclust_args(dist = list(window.size = 20L)))
  
  return(pc)
}



##############################################################################
##############################################################################
##############################################################################

library(zoo)
library(tseries)
library(tidyverse)

## generate n series:
set.seed(123)
series <- 100
years <- 50

path.series <- purrr::map_dfr(1:series, function(x){
  generateOneSeries(years=years, id=x)
})

# plot:
ggplot(path.series, aes(x=time, y=value, color=factor(id))) +
  facet_wrap(~name, scales="free") +
  geom_line() +
  guides(color="none") +
  scale_y_log10() +
  theme_minimal()

# Then we need to classify the time series.
# use dynamic time warping with dtwclust package:
library(dtwclust)

clust.op <- clusterSeries(path.series, "oilpalm")
clust.rm <- clusterSeries(path.series, "rubber")

# Cluster reference tibble:
path.series.cl <- tibble(id=unique(path.series$id), name="oilpalm", cluster=clust.op@cluster) %>% 
  rbind(tibble(id=unique(path.series$id), name="rubber", cluster=clust.rm@cluster)) %>% 
  right_join(path.series, by=c("id", "name"))


# plot cluster:
ggplot(path.series.cl, aes(x=time, y=value, color=factor(id))) +
  facet_wrap(name~cluster, scales="free") +
  geom_line() +
  guides(color="none") +
  scale_y_log10() +
  theme_minimal()


### Run model

